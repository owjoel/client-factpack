
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/owjoel/client-factpack/apps/auth/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/owjoel/client-factpack/apps/auth/config/config.go (12.5%)</option>
				
				<option value="file2">github.com/owjoel/client-factpack/apps/auth/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/owjoel/client-factpack/apps/auth/pkg/auth/auth.go (100.0%)</option>
				
				<option value="file4">github.com/owjoel/client-factpack/apps/auth/pkg/errors/aws.go (0.0%)</option>
				
				<option value="file5">github.com/owjoel/client-factpack/apps/auth/pkg/services/user.go (0.0%)</option>
				
				<option value="file6">github.com/owjoel/client-factpack/apps/auth/pkg/utils/email.go (0.0%)</option>
				
				<option value="file7">github.com/owjoel/client-factpack/apps/auth/pkg/web/handlers/auth.go (0.0%)</option>
				
				<option value="file8">github.com/owjoel/client-factpack/apps/auth/pkg/web/handlers/user.go (0.0%)</option>
				
				<option value="file9">github.com/owjoel/client-factpack/apps/auth/pkg/web/router.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/owjoel/client-factpack/apps/auth/pkg/web"
        _ "github.com/owjoel/client-factpack/apps/auth/docs"
)

//         Swagger
//        @title                        client-factpack/auth
//        @version                1.0
//        @description        Authentication service for managing auth flows
//        @host                        localhost:8080
//        @BasePath                /api/v1
// Git Workflow Test

func main() <span class="cov0" title="0">{
        web.Run()
}</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"
        "strconv"
        "strings"
)

/*
Configuration variables sourced from environment variables:
- Host: The hostname or IP where the service is running.
- ClientID: The Cognito User Pool Client ID used for authentication.
- ClientSecret: The secret associated with the Cognito User Pool Client.
- UserPoolId: The ID of the Cognito User Pool.
- AutoResetPassword: A temporary flag to enable or disable auto password reset.
*/
var (
        Host              = os.Getenv("HOST")
        AllowedDomains          = GetDomains()
        ClientID          = os.Getenv("COGNITO_USERPOOL_CLIENT_ID")
        ClientSecret      = os.Getenv("COGNITO_USERPOOL_CLIENT_SECRET")
        UserPoolID        = os.Getenv("COGNITO_USERPOOL_ID")
        AwsRegion         = os.Getenv("AWS_REGION")
        AutoResetPassword = os.Getenv("AUTO_RESET_PASSWORD") // temp flag
)

func GetDomains() []string <span class="cov8" title="1">{
        return strings.Split(os.Getenv("ALLOWED_EMAIL_DOMAINS"), ",")
}</span>

// GetPort returns the port number from the environment variable PORT.
func GetPort(defaultPort int) int <span class="cov0" title="0">{
        _port, exist := os.LookupEnv("PORT")
        if !exist </span><span class="cov0" title="0">{
                return defaultPort
        }</span>
        <span class="cov0" title="0">port, err := strconv.Atoi(_port)
        if err != nil </span><span class="cov0" title="0">{
                return defaultPort
        }</span>
        <span class="cov0" title="0">return port</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/changePassword": {
            "post": {
                "description": "Users are required to change password on first time login, using their username and password sent via email.\nSubmit The user's username and new password to respond to this auth challenge.\nRequest must contain \"session\" cookie containing the session token to respond to the challenge\nOn success, responds with next auth challenge, which should be to set up MFA",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Change Password for first-time Login",
                "parameters": [
                    {
                        "type": "string",
                        "example": "ABCDEF",
                        "name": "newPassword",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "example": "joel.ow.2022",
                        "name": "username",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.AuthChallengeRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/confirmForgetPassword": {
            "post": {
                "description": "Submit Cognito OTP sent to user's email to proceed with password reset",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Confirm Forget Password",
                "parameters": [
                    {
                        "type": "string",
                        "example": "ABCDEF",
                        "name": "code",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "example": "67890",
                        "name": "newPassword",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "example": "joel.ow.2022",
                        "name": "username",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/createUser": {
            "post": {
                "description": "Admin registers user with Cognito user pool via email. Cognito sends an email with a temporary password to the user.",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Create Users",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User's email address",
                        "name": "email",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "User's password",
                        "name": "password",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/forgetPassword": {
            "post": {
                "description": "Forget password",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Forget Password",
                "parameters": [
                    {
                        "type": "string",
                        "example": "joel.ow.2022",
                        "name": "username",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Cognito SSO login using username and password, returns the next auth challenge, either",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login",
                "parameters": [
                    {
                        "type": "string",
                        "example": "12345",
                        "name": "password",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "example": "joel.ow.2022",
                        "name": "username",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.AuthChallengeRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/loginMFA": {
            "post": {
                "description": "Responds to Cognito auth challenge after successful credential sign in\nRequest must contain \"session\" cookie containing the session token to respond to the challenge",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Submit user TOTP code from authenticator app for all subsequent log ins.",
                "parameters": [
                    {
                        "type": "string",
                        "name": "code",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "name": "username",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Clears the session by expiring the cookies containing the JWT tokens",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Logout User",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/setupMFA": {
            "get": {
                "description": "Submit GET query to cognito to obtain an OTP token.\nThe user can use this token to set up their authenticator app, either through QR code or by manual keying in of the token.\nRequest must contain \"session\" cookie containing the session token to respond to the challenge\nOn success, the token is returned, and the cookie is updated for the next auth step",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get OTP Token for setting up TOTP authenticator",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.SetupMFARes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/auth/verifyMFA": {
            "post": {
                "description": "User submits the code from their authenticator app to verify the TOTP setup\nRequest must contain \"session\" cookie containing the session token to respond to the challenge\nOn success, the user can proceed to sign in again",
                "consumes": [
                    "application/x-www-form-urlencoded"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Verify initial code from authenticator app",
                "parameters": [
                    {
                        "type": "string",
                        "name": "code",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        },
        "/health": {
            "get": {
                "description": "Basic health check",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "ping",
                "responses": {
                    "200": {
                        "description": "Connection status",
                        "schema": {
                            "$ref": "#/definitions/models.StatusRes"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.AuthChallengeRes": {
            "type": "object",
            "properties": {
                "challenge": {
                    "type": "string",
                    "enum": [
                        "NEW_PASSWORD_REQUIRED",
                        "MFA_SETUP",
                        "SOFTWARE_TOKEN_MFA"
                    ],
                    "example": "SOFTWARE_TOKEN_MFA"
                }
            }
        },
        "models.SetupMFARes": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "models.StatusRes": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "client-factpack/auth",
        Description:      "Authentication service for managing auth flows",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package auth is used to initialize the Cognito client and define the user groups.
package auth

import (
        "context"
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
)

/*
AdminGroup is the group name for admin users
AgentGroup is the group name for agent users
*/
var (
        AdminGroup = "admin"
        AgentGroup = "agent"
)

// Init initializes the Cognito client
// func Init() *cognitoidentityprovider.Client {
//         cfg, err := config.LoadDefaultConfig(context.Background())
//         if err != nil {
//                 log.Fatal(err)
//         }
//         log.Println("Cognito connected")
//         return cognitoidentityprovider.NewFromConfig(cfg)
// }

// Init initializes the Cognito client with a configurable loader function.
func Init(loadConfig func(context.Context) (aws.Config, error)) *cognitoidentityprovider.Client <span class="cov8" title="1">{
        cfg, err := loadConfig(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">log.Println("Cognito connected")
        return cognitoidentityprovider.NewFromConfig(cfg)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package errors

import (
        "errors"
        "net/http"

        "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider/types"
)

func isErrOfType[T error](err error) bool <span class="cov0" title="0">{
        var target T
        return errors.As(err, &amp;target)
}</span>

// CognitoErrorHandler handles errors from Cognito
func CognitoErrorHandler(err error) (int, string) <span class="cov0" title="0">{
        switch </span>{
        case isErrOfType[*types.UserNotFoundException](err):<span class="cov0" title="0">
                return http.StatusNotFound, "User not found"</span>
        case isErrOfType[*types.PasswordResetRequiredException](err):<span class="cov0" title="0">
                return http.StatusForbidden, "Password reset required"</span>
        case isErrOfType[*types.UserNotConfirmedException](err):<span class="cov0" title="0">
                return http.StatusForbidden, "User not confirmed"</span>
        case isErrOfType[*types.InvalidParameterException](err):<span class="cov0" title="0">
                return http.StatusBadRequest, "Invalid parameters"</span>
        case isErrOfType[*types.NotAuthorizedException](err):<span class="cov0" title="0">
                return http.StatusUnauthorized, "Incorrect username or password"</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError, "Internal server error"</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "log"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        cip "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
        "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider/types"
        "github.com/owjoel/client-factpack/apps/auth/config"
        "github.com/owjoel/client-factpack/apps/auth/pkg/api/models"
        "github.com/owjoel/client-factpack/apps/auth/pkg/auth"
)

// UserService represents the service for user operations.
type UserService struct {
        CognitoClient *cip.Client
}

// NewUserService creates a new user service.
func NewUserService() *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                CognitoClient: auth.Init(func(ctx context.Context) (aws.Config, error) </span><span class="cov0" title="0">{
                        return awsconfig.LoadDefaultConfig(ctx)
                }</span>),
        }
}

func (s *UserService) AdminCreateUser(ctx context.Context, r models.SignUpReq) error <span class="cov0" title="0">{
        username, err := createUsername(r.Email)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating username: %w", err)
        }</span>

        <span class="cov0" title="0">output, err := s.CognitoClient.AdminCreateUser(ctx, &amp;cip.AdminCreateUserInput{
                UserPoolId: aws.String(config.UserPoolID),
                Username:   aws.String(username),
                UserAttributes: []types.AttributeType{
                        {Name: aws.String("email"), Value: aws.String(r.Email)},
                        {Name: aws.String("email_verified"), Value: aws.String("true")},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error during sign up: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("User %s created at %v\n", username, output.User.UserCreateDate)

        // Add User to Group. Allow fail, add user in through AWS console
        _, err = s.CognitoClient.AdminAddUserToGroup(ctx, &amp;cip.AdminAddUserToGroupInput{
                GroupName:  aws.String(auth.AdminGroup),
                UserPoolId: aws.String(config.UserPoolID),
                Username:   aws.String(username),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Unable to add user %s into group \"%s\"\n", username, auth.AgentGroup)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SignUpUser registers user with Cognito user pool via email and password
// func (s *UserService) SignUpUser(ctx context.Context, r models.SignUpReq) error {
//         username, err := createUsername((r.Email))
//         if err != nil {
//                 return fmt.Errorf("error create username: %w", err)
//         }

//         input := &amp;cip.SignUpInput{
//                 ClientId:   aws.String(config.ClientID),
//                 Username:   aws.String(username),
//                 Password:   aws.String(r.Password),
//                 SecretHash: aws.String(CalculateSecretHash(username)),
//                 UserAttributes: []types.AttributeType{{
//                         Name: aws.String("email"), Value: aws.String(r.Email),
//                 }},
//         }

//         _, err = s.CognitoClient.SignUp(ctx, input)
//         if err != nil {
//                 return fmt.Errorf("error during sign up: %w", err)
//         }
//         log.Printf("User %s created", username)

//         // Add User to Group. Allow fail, add user in through AWS console
//         _, err = s.CognitoClient.AdminAddUserToGroup(ctx, &amp;cip.AdminAddUserToGroupInput{
//                 GroupName:  aws.String(auth.AdminGroup),
//                 UserPoolId: aws.String(config.UserPoolID),
//                 Username:   aws.String(username),
//         })
//         if err != nil {
//                 log.Printf("Unable to add user %s into group \"%s\"\n", username, auth.AgentGroup)
//         }
//         return nil
// }

func createUsername(email string) (string, error) <span class="cov0" title="0">{
        username := strings.Split(email, "@")[0]
        if len(username) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return username, nil</span>
}

// CalculateSecretHash calculates the secret hash for Cognito
func CalculateSecretHash(username string) string <span class="cov0" title="0">{
        message := username + config.ClientID
        h := hmac.New(sha256.New, []byte(config.ClientSecret))
        h.Write([]byte(message))

        return base64.StdEncoding.EncodeToString(h.Sum(nil))
}</span>

// ForgetPassword sends a password reset code to the user's email
func (s *UserService) ForgetPassword(ctx context.Context, r models.ForgetPasswordReq) error <span class="cov0" title="0">{

        username := r.Username

        input := &amp;cip.ForgotPasswordInput{
                ClientId:   aws.String(config.ClientID),
                Username:   aws.String(username),
                SecretHash: aws.String(CalculateSecretHash(username)),
        }

        _, err := s.CognitoClient.ForgotPassword(context.Background(), input)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("failed to initiate password reset: %s", err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Password reset code sent successfully")
        return nil</span>
}

// UserLogin authenticates user with Cognito user pool via email and password
func (s *UserService) UserLogin(ctx context.Context, r models.LoginReq) (*models.LoginRes, error) <span class="cov0" title="0">{

        input := &amp;cip.InitiateAuthInput{
                AuthFlow: types.AuthFlowTypeUserPasswordAuth,
                AuthParameters: map[string]string{
                        "USERNAME":    r.Username,
                        "PASSWORD":    r.Password,
                        "SECRET_HASH": CalculateSecretHash(r.Username),
                },
                ClientId: aws.String(config.ClientID),
        }

        // returns tokens on success, see https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_InitiateAuth.html
        response, err := s.CognitoClient.InitiateAuth(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initiate auth: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.LoginRes{
                Challenge: getChallengeName(response.ChallengeName),
                Session:   *response.Session,
        }, nil</span>

        // Return based on challenges
        // if response.ChallengeName == types.ChallengeNameTypeNewPasswordRequired {
        //         fmt.Println("New password required") // TODO: return Session token or store it in db

        //         // TODO: (FOR TESTING ONLY) remove in future
        //         err := s.handleNewPasswordChallenge(ctx, r.Username, "Password@1", *response.Session)
        //         if err != nil {
        //                 return err
        //         }
        //         fmt.Println("Password updated successfully.")
        // } else {
        //         fmt.Println("Authentication successful.")
        // }

        // If challenge is to set up MFA on first time login, get OTP and send back as QR code
        // if response.ChallengeName == types.ChallengeNameTypeMfaSetup {
        //         fmt.Println("Setup MFA required")

        //         secretKey, err := s.AssociateToken(ctx, *response.Session)
        //         if err != nil {
        //                 return nil
        //         }
        // }
}

// SetNewPassword is used to set a new password for the user and check for next auth challenge
func (s *UserService) SetNewPassword(ctx context.Context, r models.SetNewPasswordReq) (*models.SetNewPasswordRes, error) <span class="cov0" title="0">{
        autoResetEnabled, err := strconv.ParseBool(config.AutoResetPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid AUTO_RESET_PASSWORD value: %w", err)
        }</span>

        <span class="cov0" title="0">if !autoResetEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("auto-reset password is disabled")
        }</span>

        <span class="cov0" title="0">challengeInput := &amp;cip.RespondToAuthChallengeInput{
                ClientId:      aws.String(config.ClientID),
                ChallengeName: types.ChallengeNameTypeNewPasswordRequired,
                Session:       aws.String(r.Session),
                ChallengeResponses: map[string]string{
                        "USERNAME":     r.Username,
                        "NEW_PASSWORD": r.NewPassword,
                        "SECRET_HASH":  CalculateSecretHash(r.Username),
                },
        }

        res, err := s.CognitoClient.RespondToAuthChallenge(ctx, challengeInput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to respond to auth challenge: %s", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.SetNewPasswordRes{
                Challenge: getChallengeName(res.ChallengeName),
                Session:   *res.Session,
        }, nil</span>
}

// SetupMFA is used to associate the user's auth challenge session with the account
// Returns an OTP which can be returned as a QR to the client
func (s *UserService) SetupMFA(ctx context.Context, session string) (*models.AssociateTokenRes, error) <span class="cov0" title="0">{
        input := &amp;cip.AssociateSoftwareTokenInput{
                Session: aws.String(session),
        }
        res, err := s.CognitoClient.AssociateSoftwareToken(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error associating token: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.AssociateTokenRes{
                Token:   *res.SecretCode,
                Session: *res.Session,
        }, nil</span>
}

// VerifyMFA is used to verify the MFA code from the user's authentication app
// Submit code from user's authentication app. Cognito will update MFA settings, but does not complete authentication.
// Nothing is returned to user on success.
func (s *UserService) VerifyMFA(ctx context.Context, r models.VerifyMFAReq) error <span class="cov0" title="0">{
        input := &amp;cip.VerifySoftwareTokenInput{
                Session:  aws.String(r.Session),
                UserCode: aws.String(r.Code),
        }
        res, err := s.CognitoClient.VerifySoftwareToken(ctx, input)
        if err != nil || res.Status != "SUCCESS" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify MFA: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SignInMFA is used to sign in with MFA
func (s *UserService) SignInMFA(ctx context.Context, r models.SignInMFAReq) (models.AuthenticationRes, error) <span class="cov0" title="0">{
        input := &amp;cip.RespondToAuthChallengeInput{
                ChallengeName: types.ChallengeNameTypeSoftwareTokenMfa,
                ClientId:      aws.String(config.ClientID),
                Session:       aws.String(r.Session),
                ChallengeResponses: map[string]string{
                        "USERNAME":                r.Username,
                        "SECRET_HASH":             CalculateSecretHash(r.Username),
                        "SOFTWARE_TOKEN_MFA_CODE": r.Code,
                },
        }
        res, err := s.CognitoClient.RespondToAuthChallenge(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return models.AuthenticationRes{}, fmt.Errorf("failed to sign in with MFA: %w", err)
        }</span>
        <span class="cov0" title="0">return models.AuthenticationRes{Result: *res.AuthenticationResult, Challenge: getChallengeName(res.ChallengeName)}, nil</span>
}

// ConfirmForgetPassword is used to confirm the password reset.
func (s *UserService) ConfirmForgetPassword(ctx context.Context, r models.ConfirmForgetPasswordReq) error <span class="cov0" title="0">{
        input := &amp;cip.ConfirmForgotPasswordInput{
                ClientId:         aws.String(config.ClientID),
                Username:         aws.String(r.Username),
                Password:         aws.String(r.NewPassword),
                ConfirmationCode: aws.String(r.Code),
                SecretHash:       aws.String(CalculateSecretHash(r.Username)),
        }

        _, err := s.CognitoClient.ConfirmForgotPassword(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("failed to confirm password reset: %s\n", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func (s *UserService) handleNewPasswordChallenge(ctx context.Context, username, newPassword, session string) error {
//         // flag for testing
//         autoResetEnabled, err := strconv.ParseBool(config.AutoResetPassword)
//         if err != nil {
//                 return fmt.Errorf("invalid AUTO_RESET_PASSWORD value: %w", err)
//         }

//         if !autoResetEnabled {
//                 return fmt.Errorf("auto-reset password is disabled")
//         }

//         challengeInput := &amp;cognitoidentityprovider.RespondToAuthChallengeInput{
//                 ClientId:      aws.String(config.ClientId),
//                 ChallengeName: types.ChallengeNameTypeNewPasswordRequired,
//                 Session:       aws.String(session),
//                 ChallengeResponses: map[string]string{
//                         "USERNAME":     username,
//                         "NEW_PASSWORD": newPassword,
//                         "SECRET_HASH": CalculateSecretHash(username),
//                 },
//         }

//         _, err = s.CognitoClient.RespondToAuthChallenge(ctx, challengeInput)
//         if err != nil {
//                 fmt.Printf("failed to respond to auth challenge: %s", err)
//                 return err
//         }

//         return nil
// }

// Returns the string value of the auth challenge that should be returned to the client
func getChallengeName(challenge types.ChallengeNameType) string <span class="cov0" title="0">{
        if challenge == types.ChallengeNameTypeNewPasswordRequired </span><span class="cov0" title="0">{
                return "NEW_PASSWORD_REQUIRED"
        }</span> else<span class="cov0" title="0"> if challenge == types.ChallengeNameTypeMfaSetup </span><span class="cov0" title="0">{
                return "MFA_SETUP"
        }</span> else<span class="cov0" title="0"> if challenge == types.ChallengeNameTypeSoftwareTokenMfa </span><span class="cov0" title="0">{
                return "SOFTWARE_TOKEN_MFA"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package utils

import "github.com/owjoel/client-factpack/apps/auth/config"

// Checks email domain against allowed list, set through app environment variables
func IsAllowedDomain(domain string) bool <span class="cov0" title="0">{
        for _, d := range config.AllowedDomains </span><span class="cov0" title="0">{
                if domain == d </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/MicahParks/keyfunc/v2"
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/owjoel/client-factpack/apps/auth/config"
)

// Authenticate is a middleware that checks if the user is authenticated by validating the "accessToken" cookie.
// If the cookie is missing or invalid, it returns a 403 Forbidden response.
// Otherwise, it sets the token in the context for downstream handlers to use.
func (h *UserHandler) Authenticate(c *gin.Context) <span class="cov0" title="0">{

        requiredTokenUse := "access" // default check for access token
        awsDefaultRegion := config.AwsRegion
        cognitoUserPoolId := config.UserPoolID
        cognitoAppClientId := config.ClientID

        jwks, err := GetJWKS(awsDefaultRegion, cognitoUserPoolId)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to retrieve Cognito JWKS\nError: %s", err)
        }</span>

        <span class="cov0" title="0">tokenString, err := c.Cookie("access_token")
        if err != nil || tokenString == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // * Verify the signature of the JWT
        // * Verify that the algorithm used is RS256
        // * Verify that the 'exp' claim exists in the token
        // * Verification of audience 'aud' is taken care later when we examine if the
        //   token is 'id' or 'access'
        // * The issuer (iss) claim should match your user pool. For example, a user
        //   pool created in the us-east-1 region
        //   will have the following iss value: https://cognito-idp.us-east-1.amazonaws.com/&lt;userpoolID&gt;.
        <span class="cov0" title="0">token, err := jwt.Parse(tokenString,
                jwks.Keyfunc,
                jwt.WithValidMethods([]string{"RS256"}),
                jwt.WithExpirationRequired(),
                jwt.WithIssuer(fmt.Sprintf("https://cognito-idp.%s.amazonaws.com/%s", awsDefaultRegion, cognitoUserPoolId)))
        if err != nil || !token.Valid </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // Attempt to parse the JWT claims
        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // Compare the "exp" claim to the current time
        <span class="cov0" title="0">expClaim, err := claims.GetExpirationTime()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">if expClaim.Unix() &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // Check the token_use claim.
        // If you are only accepting the access token in your web API operations, its value must be access.
        // If you are only using the ID token, its value must be id.
        // If you are using both ID and access tokens, the token_use claim must be either id or access.
        <span class="cov0" title="0">tokenUseClaim, ok := claims["token_use"].(string)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">if tokenUseClaim != requiredTokenUse </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // "sub" claim exists in both ID and Access tokens
        <span class="cov0" title="0">subClaim, err := claims.GetSubject()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">c.Set("username", subClaim)

        // The "aud" claim in an ID token and the "client_id" claim in an access token should match the app
        // client ID that was created in the Amazon Cognito user pool.
        var appClientIdClaim string
        if tokenUseClaim == "id" </span><span class="cov0" title="0">{
                audienceClaims, err := claims.GetAudience()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">appClientIdClaim = audienceClaims[0]</span>

        } else<span class="cov0" title="0"> if tokenUseClaim == "access" </span><span class="cov0" title="0">{
                clientIdClaim, ok := claims["client_id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">appClientIdClaim = clientIdClaim</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">if appClientIdClaim != cognitoAppClientId </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                c.Abort()
                return
        }</span>

        // Retrieve any Cognito user groups that the user belongs to
        <span class="cov0" title="0">userGroupsAttribute, ok := claims["cognito:groups"]
        userGroupsClaims := make([]string, 0)
        if ok </span><span class="cov0" title="0">{
                switch x := userGroupsAttribute.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        for _, e := range x </span><span class="cov0" title="0">{
                                userGroupsClaims = append(userGroupsClaims, e.(string))
                        }</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                        c.Abort()
                        return</span>
                }
        }

        <span class="cov0" title="0">c.Set("groups", userGroupsClaims)

        c.Next()

        c.Set("accessToken", token)
        c.Next()</span>
}

// VerifyMFA verifies the user's multi-factor authentication (MFA) setup using their access token.
// It retrieves the "accessToken" from the context, and if it doesn't exist, returns a 403 Forbidden response.
// If the token exists, it prepares the input for associating an MFA software token with AWS Cognito.
func (h *UserHandler) VerifyMFA(c *gin.Context) <span class="cov0" title="0">{
        token, exists := c.Get("accessToken")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"message": "Could not verify identity"})
        }</span>
        <span class="cov0" title="0">tokenString := fmt.Sprintf("%v", token)
        input := &amp;cognitoidentityprovider.AssociateSoftwareTokenInput{
                AccessToken: aws.String(tokenString),
        }
        log.Println(input)</span>
}

// Helper function for Authenticate middleware
func GetJWKS(awsRegion string, cognitoUserPoolId string) (*keyfunc.JWKS, error) <span class="cov0" title="0">{

        jwksURL := fmt.Sprintf("https://cognito-idp.%s.amazonaws.com/%s/.well-known/jwks.json", awsRegion, cognitoUserPoolId)

        jwks, err := keyfunc.Get(jwksURL, keyfunc.Options{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jwks, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "net/mail"

        "github.com/gin-gonic/gin"
        "github.com/owjoel/client-factpack/apps/auth/config"
        "github.com/owjoel/client-factpack/apps/auth/pkg/api/models"
        "github.com/owjoel/client-factpack/apps/auth/pkg/errors"
        "github.com/owjoel/client-factpack/apps/auth/pkg/services"
)

// UserHandler represents the handler for user operations.
type UserHandler struct {
        service *services.UserService
}

// New creates a new user handler.
func New() *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{service: services.NewUserService()}
}</span>

// HealthCheck is a basic health check
//        @Summary                ping
//        @Description        Basic health check
//        @Tags                        health
//        @Produce                json
//        @Success                200        {object}        models.StatusRes        "Connection status"
//        @Router                        /health [get]
func (h *UserHandler) HealthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, models.StatusRes{Status: "Connection successful"})
}</span>

// CreateUser registers user with Cognito user pool via email and password
//        @Summary                Create Users
//        @Description        Admin registers user with Cognito user pool via email. Cognito sends an email with a temporary password to the user.
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        email                formData        string        true        "User's email address"
//        @Param                        password        formData        string        true        "User's password"
//        @Success                200                        {object}        models.StatusRes
//        @Failure                400                        {object}        models.StatusRes
//        @Failure                500                        {object}        models.StatusRes
//        @Router                        /auth/createUser [post]
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        var req models.SignUpReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Error"})
                return
        }</span>

        // Validate email
        <span class="cov0" title="0">if _, err := mail.ParseAddress(req.Email); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Invalid Email"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.AdminCreateUser(c.Request.Context(), req); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", err)
                c.JSON(http.StatusInternalServerError, models.StatusRes{Status: "Failed to sign up user"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.StatusRes{Status: "Success"})</span>
}

// ForgetPassword sends a reset password email to the user
//        @Summary                Forget Password
//        @Description        Forget password
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.ForgetPasswordReq        true        "Username"
//        @Success                200                {object}        models.StatusRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Failure                403                {object}        models.StatusRes
//        @Failure                404                {object}        models.StatusRes
//        @Router                        /auth/forgetPassword [post]
func (h *UserHandler) ForgetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req models.ForgetPasswordReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Error"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ForgetPassword(c.Request.Context(), req); err != nil </span><span class="cov0" title="0">{
                status, message := errors.CognitoErrorHandler(err)
                fmt.Println(status, message)
                c.JSON(status, models.StatusRes{Status: message})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "If you have an account, you will receive an email with instructions on how to reset your password."})</span>
}


//        @Summary                Login
//        @Description        Cognito SSO login using username and password, returns the next auth challenge, either 
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.LoginReq        true        "Username, Password"
//        @Success                200                {object}        models.AuthChallengeRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Failure                403                {object}        models.StatusRes
//        @Failure                404                {object}        models.StatusRes
//        @Router                        /auth/login [post]
func (h *UserHandler) UserLogin(c *gin.Context) <span class="cov0" title="0">{
        var req models.LoginReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Invalid Form Data"})
                return
        }</span>

        <span class="cov0" title="0">res, err := h.service.UserLogin(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                status, message := errors.CognitoErrorHandler(err)
                log.Printf("Status: %d, Message: %s\n", status, message)
                c.JSON(status, models.StatusRes{Status: message})
                return
        }</span>

        // TODO: return some token probs
        <span class="cov0" title="0">c.SetCookie("session", res.Session, 3600, "/", config.Host, false, true)
        c.JSON(http.StatusOK, models.AuthChallengeRes{Challenge: res.Challenge})</span>
}


//        @Summary                Change Password for first-time Login
//        @Description        Users are required to change password on first time login, using their username and password sent via email.
//        @Description        Submit The user's username and new password to respond to this auth challenge.
//        @Description        Request must contain "session" cookie containing the session token to respond to the challenge
//        @Description        On success, responds with next auth challenge, which should be to set up MFA
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.SetNewPasswordReq        true        "Username, New Password"
//        @Success                200                {object}        models.AuthChallengeRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Router                        /auth/changePassword [post]
func (h *UserHandler) UserInitialChangePassword(c *gin.Context) <span class="cov0" title="0">{
        var req models.SetNewPasswordReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Invalid Form Data"})
                return
        }</span>

        <span class="cov0" title="0">session, err := c.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Missing session cookie for auth challenge")
                c.JSON(http.StatusUnauthorized, models.StatusRes{Status: "Session cookie missing"})
                return
        }</span>
        <span class="cov0" title="0">req.Session = session

        res, err := h.service.SetNewPassword(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error while changing user password: %w", err))
        }</span>
        <span class="cov0" title="0">c.SetCookie("session", res.Session, 3600, "/", config.Host, false, true)
        c.JSON(http.StatusOK, models.AuthChallengeRes{Challenge: res.Challenge})</span>
}

//        @Summary                Get OTP Token for setting up TOTP authenticator
//        @Description        Submit GET query to cognito to obtain an OTP token. 
//        @Description        The user can use this token to set up their authenticator app, either through QR code or by manual keying in of the token.
//        @Description        Request must contain "session" cookie containing the session token to respond to the challenge
//        @Description        On success, the token is returned, and the cookie is updated for the next auth step
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Success                200        {object}        models.SetupMFARes
//        @Failure                401        {object}        models.StatusRes
//        @Failure                500        {object}        models.StatusRes
//        @Router                        /auth/setupMFA [get]
func (h *UserHandler) UserSetupMFA(c *gin.Context) <span class="cov0" title="0">{
        session, err := c.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Missing session cookie for auth challenge")
                c.JSON(http.StatusUnauthorized, models.StatusRes{Status: "Session cookie missing"})
                return
        }</span>

        <span class="cov0" title="0">res, err := h.service.SetupMFA(c.Request.Context(), session)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error setting up mfa: %w", err))
                c.JSON(http.StatusInternalServerError, models.StatusRes{Status: "Unable to return token. Please check server logs"})
                return
        }</span>
        <span class="cov0" title="0">c.SetCookie("session", res.Session, 3600, "/", config.Host, false, true)
        c.JSON(http.StatusOK, models.SetupMFARes{Token: res.Token})</span>
}

//        @Summary                Verify initial code from authenticator app
//        @Description        User submits the code from their authenticator app to verify the TOTP setup
//        @Description        Request must contain "session" cookie containing the session token to respond to the challenge
//        @Description        On success, the user can proceed to sign in again
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.VerifyMFAReq        true        "TOTP Code"
//        @Success                200                {object}        models.StatusRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Failure                500                {object}        models.StatusRes
//        @Router                        /auth/verifyMFA [post]
func (h *UserHandler) UserVerifyMFA(c *gin.Context) <span class="cov0" title="0">{
        var req models.VerifyMFAReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Invalid Form Data"})
                return
        }</span>

        <span class="cov0" title="0">session, err := c.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Missing session cookie for auth challenge")
                c.JSON(http.StatusUnauthorized, models.StatusRes{Status: "Session cookie missing"})
                return
        }</span>

        <span class="cov0" title="0">req.Session = session

        if err := h.service.VerifyMFA(c.Request.Context(), req); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error verifying MFA: %w", err))
                c.JSON(http.StatusInternalServerError, models.StatusRes{Status: "Could not verify"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.StatusRes{Status: "Success"})</span>
}

//        @Summary                Submit user TOTP code from authenticator app for all subsequent log ins. 
//        @Description        Responds to Cognito auth challenge after successful credential sign in
//        @Description        Request must contain "session" cookie containing the session token to respond to the challenge
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.SignInMFAReq        true        "Username, TOTP Code"
//        @Success                200                {object}        models.StatusRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Failure                500                {object}        models.StatusRes
//        @Router                        /auth/loginMFA [post]
func (h *UserHandler) UserLoginMFA(c *gin.Context) <span class="cov0" title="0">{
        var req models.SignInMFAReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Invalid Form Data"})
                return
        }</span>

        <span class="cov0" title="0">session, err := c.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Missing session cookie for auth challenge")
                c.JSON(http.StatusUnauthorized, models.StatusRes{Status: "Session cookie missing"})
                return
        }</span>
        <span class="cov0" title="0">req.Session = session

        auth, err := h.service.SignInMFA(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%v", fmt.Errorf("error verifying totp code: %w", err))
                c.JSON(http.StatusInternalServerError, models.StatusRes{Status: "Unable to return token. Please check server logs"})
                return
        }</span>

        <span class="cov0" title="0">if auth.Challenge != "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.StatusRes{Status: "Unexpected challenge"})
        }</span>
        <span class="cov0" title="0">c.SetCookie("access_token", *auth.Result.AccessToken, 3600, "/", config.Host, false, true)
        c.SetCookie("id_token", *auth.Result.IdToken, 3600, "/", config.Host, false, true)
        c.JSON(http.StatusOK, models.StatusRes{Status: "Login Successful"})</span>
}

//        @Summary                Confirm Forget Password
//        @Description        Submit Cognito OTP sent to user's email to proceed with password reset
//        @Tags                        auth
//        @Accept                        application/x-www-form-urlencoded
//        @Produce                json
//        @Param                        request        formData        models.ConfirmForgetPasswordReq        true        "OTP Code"
//        @Success                200                {object}        models.StatusRes
//        @Failure                400                {object}        models.StatusRes
//        @Failure                401                {object}        models.StatusRes
//        @Failure                403                {object}        models.StatusRes
//        @Failure                404                {object}        models.StatusRes
//        @Router                        /auth/confirmForgetPassword [post]
func (h *UserHandler) ConfirmForgetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req models.ConfirmForgetPasswordReq
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%v", fmt.Errorf("error binding request: %w", err))
                c.JSON(http.StatusBadRequest, models.StatusRes{Status: "Error"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ConfirmForgetPassword(c.Request.Context(), req); err != nil </span><span class="cov0" title="0">{
                status, message := errors.CognitoErrorHandler(err)
                fmt.Println(status, message)
                c.JSON(status, models.StatusRes{Status: message})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "Successfully reset password"})</span>
}

// Logout clears the access token and ID token by expiring their cookies
// @Summary Logout User
// @Description Clears the session by expiring the cookies containing the JWT tokens
// @Tags auth
// @Produce json
// @Success 200 {object} models.StatusRes
//        @Router                        /auth/logout [post]
func (h *UserHandler) UserLogout(c *gin.Context) <span class="cov0" title="0">{
        c.SetCookie("access_token","", -1, "/", config.Host, false, true)
        c.SetCookie("id_token","", -1, "/", config.Host, false, true)
        c.SetCookie("session","", -1, "/", config.Host, false, true)

        c.JSON(http.StatusOK, gin.H{"status": "Logout successful"})
}</pre>
		
		<pre class="file" id="file9" style="display: none">package web

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/pprof"
        "github.com/gin-gonic/gin"
        "github.com/owjoel/client-factpack/apps/auth/config"
        "github.com/owjoel/client-factpack/apps/auth/pkg/web/handlers"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// Router represents the router for the web service.
type Router struct {
        *gin.Engine
}

// NewRouter creates a new router.
func NewRouter() *Router <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        router := gin.Default()

        // enable CORS
        router.Use(
                cors.New(cors.Config{
                        AllowOrigins:     []string{"http://localhost:5173"},
                        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                        AllowHeaders:     []string{"Content-Type", "Authorization"},
                        AllowCredentials: true,
                }),
        )

        pprof.Register(router)

        handler := handlers.New()

        // Use RPC styling rather than REST
        v1API := router.Group("/api/v1")
        v1API.GET("/health", handler.HealthCheck)
        </span><span class="cov0" title="0">{
                auth := v1API.Group("/auth")
                auth.POST("/createUser", handler.CreateUser)
                auth.POST("/forgetPassword", handler.ForgetPassword)
                auth.POST("/confirmForgetPassword", handler.ConfirmForgetPassword)

                auth.POST("/login", handler.UserLogin)
                auth.POST("/changePassword", handler.UserInitialChangePassword)
                auth.GET("/setupMFA", handler.UserSetupMFA)
                auth.POST("/verifyMFA", handler.UserVerifyMFA)
                auth.POST("/loginMFA", handler.UserLoginMFA)
                auth.GET("/checkUser", handler.Authenticate, handler.HealthCheck)
                auth.POST("/logout", handler.UserLogout)
        }</span>

        <span class="cov0" title="0">router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))

        return &amp;Router{router}</span>
}

// Run starts the web service.
func (r *Router) Run() <span class="cov0" title="0">{
        port := config.GetPort(8080)
        srv := &amp;http.Server{
                Addr:    fmt.Sprintf(":%v", port),
                Handler: r.Engine,
        }

        go func() </span><span class="cov0" title="0">{
                err := srv.ListenAndServe()
                if err == http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Server closed: %v\n", err)
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to listen and serve: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("server forced to shutdown: %v", err)
        }</span>

}

// Run starts the web service.
func Run() <span class="cov0" title="0">{
        NewRouter().Run()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
