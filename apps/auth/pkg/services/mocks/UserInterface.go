// Code generated by mockery v2.52.3. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/owjoel/client-factpack/apps/auth/pkg/api/models"
	mock "github.com/stretchr/testify/mock"
)

// UserInterface is an autogenerated mock type for the UserInterface type
type UserInterface struct {
	mock.Mock
}

// AdminCreateUser provides a mock function with given fields: ctx, r
func (_m *UserInterface) AdminCreateUser(ctx context.Context, r models.SignUpReq) error {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for AdminCreateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.SignUpReq) error); ok {
		r0 = rf(ctx, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfirmForgetPassword provides a mock function with given fields: ctx, r
func (_m *UserInterface) ConfirmForgetPassword(ctx context.Context, r models.ConfirmForgetPasswordReq) error {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmForgetPassword")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.ConfirmForgetPasswordReq) error); ok {
		r0 = rf(ctx, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ForgetPassword provides a mock function with given fields: ctx, r
func (_m *UserInterface) ForgetPassword(ctx context.Context, r models.ForgetPasswordReq) error {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for ForgetPassword")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.ForgetPasswordReq) error); ok {
		r0 = rf(ctx, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetNewPassword provides a mock function with given fields: ctx, r
func (_m *UserInterface) SetNewPassword(ctx context.Context, r models.SetNewPasswordReq) (*models.SetNewPasswordRes, error) {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for SetNewPassword")
	}

	var r0 *models.SetNewPasswordRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.SetNewPasswordReq) (*models.SetNewPasswordRes, error)); ok {
		return rf(ctx, r)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.SetNewPasswordReq) *models.SetNewPasswordRes); ok {
		r0 = rf(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SetNewPasswordRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.SetNewPasswordReq) error); ok {
		r1 = rf(ctx, r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetupMFA provides a mock function with given fields: ctx, session
func (_m *UserInterface) SetupMFA(ctx context.Context, session string) (*models.AssociateTokenRes, error) {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for SetupMFA")
	}

	var r0 *models.AssociateTokenRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.AssociateTokenRes, error)); ok {
		return rf(ctx, session)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.AssociateTokenRes); ok {
		r0 = rf(ctx, session)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.AssociateTokenRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, session)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignInMFA provides a mock function with given fields: ctx, r
func (_m *UserInterface) SignInMFA(ctx context.Context, r models.SignInMFAReq) (models.AuthenticationRes, error) {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for SignInMFA")
	}

	var r0 models.AuthenticationRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.SignInMFAReq) (models.AuthenticationRes, error)); ok {
		return rf(ctx, r)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.SignInMFAReq) models.AuthenticationRes); ok {
		r0 = rf(ctx, r)
	} else {
		r0 = ret.Get(0).(models.AuthenticationRes)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.SignInMFAReq) error); ok {
		r1 = rf(ctx, r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserLogin provides a mock function with given fields: ctx, r
func (_m *UserInterface) UserLogin(ctx context.Context, r models.LoginReq) (*models.LoginRes, error) {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for UserLogin")
	}

	var r0 *models.LoginRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.LoginReq) (*models.LoginRes, error)); ok {
		return rf(ctx, r)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.LoginReq) *models.LoginRes); ok {
		r0 = rf(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.LoginRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.LoginReq) error); ok {
		r1 = rf(ctx, r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyMFA provides a mock function with given fields: ctx, r
func (_m *UserInterface) VerifyMFA(ctx context.Context, r models.VerifyMFAReq) error {
	ret := _m.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMFA")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.VerifyMFAReq) error); ok {
		r0 = rf(ctx, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewUserInterface creates a new instance of UserInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *UserInterface {
	mock := &UserInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
